---
title: Cluster Mode
description: Utilize todos os n√∫cleos da CPU com cluster mode
icon: Monitor
---

# Cluster Mode üñ•Ô∏è

Cluster mode permite que sua aplica√ß√£o AzuraJS utilize todos os n√∫cleos da CPU, melhorando significativamente o desempenho e a capacidade de requisi√ß√µes.

## B√°sico do Cluster Mode üí°

O Node.js executa em uma √∫nica thread por padr√£o. Cluster mode cria m√∫ltiplos processos worker, cada um em seu pr√≥prio n√∫cleo de CPU.

```typescript
import { AzuraClient } from "azurajs";
import cluster from "cluster";
import { cpus } from "os";

const numCPUs = cpus().length;

if (cluster.isPrimary) {
  console.log(`Primary process ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on("exit", (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    // Restart worker
    cluster.fork();
  });
} else {
  // Workers compartilham a porta TCP
  const app = new AzuraClient();
  
  // Registrar controllers
  applyDecorators(app, [UserController, PostController]);
  
  await app.listen(3000);
  console.log(`Worker ${process.pid} started`);
}
```

## Configura√ß√£o Completa üîß

### Cluster com Configura√ß√£o Avan√ßada

```typescript
import cluster from "cluster";
import { cpus } from "os";
import { AzuraClient, applyDecorators } from "azurajs";
import { UserController } from "./controllers/UserController";

const numCPUs = cpus().length;
const PORT = process.env.PORT || 3000;

if (cluster.isPrimary) {
  console.log(`üöÄ Primary ${process.pid} is running`);
  console.log(`üìä CPU cores: ${numCPUs}`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    const worker = cluster.fork();
    console.log(`üî∑ Worker ${worker.process.pid} started`);
  }
  
  // Monitorar workers
  cluster.on("online", (worker) => {
    console.log(`‚úÖ Worker ${worker.process.pid} is online`);
  });
  
  cluster.on("exit", (worker, code, signal) => {
    console.log(`‚ùå Worker ${worker.process.pid} died (${signal || code})`);
    
    // Reiniciar worker
    const newWorker = cluster.fork();
    console.log(`üîÑ New worker ${newWorker.process.pid} started`);
  });
  
  // Graceful shutdown
  process.on("SIGTERM", () => {
    console.log("SIGTERM received, shutting down workers...");
    
    for (const id in cluster.workers) {
      cluster.workers[id]?.kill();
    }
  });
  
} else {
  // Worker process
  const app = new AzuraClient({
    environment: "production",
    server: {
      port: PORT
    },
    logging: {
      level: "info"
    }
  });
  
  // Registrar controllers
  applyDecorators(app, [UserController]);
  
  // Iniciar servidor
  await app.listen(PORT);
  console.log(`Worker ${process.pid} listening on port ${PORT}`);
}
```

## N√∫mero Ideal de Workers üìä

```typescript
// Usar todos os n√∫cleos
const numCPUs = cpus().length;

// Usar todos exceto um (deixar um core livre para o sistema)
const numWorkers = Math.max(1, numCPUs - 1);

// Usar metade dos n√∫cleos (para ambientes compartilhados)
const numWorkers = Math.max(1, Math.floor(numCPUs / 2));

// Usar n√∫mero configur√°vel
const numWorkers = process.env.WORKERS 
  ? parseInt(process.env.WORKERS) 
  : numCPUs;
```

## Comunica√ß√£o entre Workers üí¨

Workers podem se comunicar atrav√©s do processo primary:

```typescript
if (cluster.isPrimary) {
  const stats = {
    requests: 0,
    errors: 0
  };
  
  cluster.on("message", (worker, message) => {
    if (message.type === "request") {
      stats.requests++;
    } else if (message.type === "error") {
      stats.errors++;
    }
    
    // Broadcast stats para todos os workers
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "stats", data: stats });
    }
  });
  
} else {
  // Worker
  const app = new AzuraClient();
  
  app.use((req, res, next) => {
    // Notificar primary sobre requisi√ß√£o
    process.send?.({ type: "request" });
    next();
  });
  
  // Receber mensagens do primary
  process.on("message", (message) => {
    if (message.type === "stats") {
      console.log("Global stats:", message.data);
    }
  });
}
```

## Estado Compartilhado üîÑ

Workers n√£o compartilham mem√≥ria. Use Redis ou banco de dados para estado compartilhado:

```typescript
import { createClient } from "redis";

const redis = createClient({ url: "redis://localhost:6379" });
await redis.connect();

@Controller("/api")
export class ApiController {
  @Get("/counter")
  async getCounter() {
    // Incrementar contador compartilhado
    const count = await redis.incr("global-counter");
    return { count, worker: process.pid };
  }

  @Post("/cache")
  async setCache(@Body() data: any) {
    // Cache compartilhado entre workers
    await redis.setEx(`cache:${data.key}`, 3600, JSON.stringify(data.value));
    return { cached: true };
  }
}
```

## Sess√µes em Cluster Mode üîê

Use Redis para armazenar sess√µes:

```typescript
import { createClient } from "redis";

const redis = createClient();
await redis.connect();

// Middleware de sess√£o
async function sessionMiddleware(
  req: RequestServer,
  res: ResponseServer,
  next: () => void
) {
  const sessionId = req.cookies.sessionId;
  
  if (sessionId) {
    const sessionData = await redis.get(`session:${sessionId}`);
    if (sessionData) {
      req.session = JSON.parse(sessionData);
    }
  }
  
  // Salvar sess√£o ao finalizar
  const originalJson = res.json.bind(res);
  res.json = async function(data: any) {
    if (req.session) {
      await redis.setEx(
        `session:${sessionId}`,
        3600,
        JSON.stringify(req.session)
      );
    }
    return originalJson(data);
  };
  
  next();
}

app.use(sessionMiddleware);
```

## Monitoramento de Workers üìà

### Middleware de M√©tricas

```typescript
if (cluster.isPrimary) {
  const workerStats = new Map();
  
  // Coletar estat√≠sticas
  setInterval(() => {
    for (const id in cluster.workers) {
      const worker = cluster.workers[id];
      worker?.send({ type: "request-stats" });
    }
  }, 10000);  // A cada 10 segundos
  
  cluster.on("message", (worker, message) => {
    if (message.type === "stats") {
      workerStats.set(worker.id, message.data);
      
      // Calcular estat√≠sticas globais
      let totalRequests = 0;
      let totalErrors = 0;
      
      workerStats.forEach(stats => {
        totalRequests += stats.requests;
        totalErrors += stats.errors;
      });
      
      console.log(`üìä Total: ${totalRequests} requests, ${totalErrors} errors`);
    }
  });
  
} else {
  let workerRequests = 0;
  let workerErrors = 0;
  
  app.use((req, res, next) => {
    workerRequests++;
    next();
  });
  
  process.on("message", (message) => {
    if (message.type === "request-stats") {
      process.send?.({
        type: "stats",
        data: {
          requests: workerRequests,
          errors: workerErrors,
          pid: process.pid
        }
      });
    }
  });
}
```

## Graceful Shutdown üõë

Implemente shutdown gracioso para n√£o perder requisi√ß√µes:

```typescript
if (cluster.isPrimary) {
  process.on("SIGTERM", async () => {
    console.log("Iniciando graceful shutdown...");
    
    // Notificar workers para parar de aceitar novas conex√µes
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "shutdown" });
    }
    
    // Aguardar workers finalizarem
    await new Promise((resolve) => {
      const timeout = setTimeout(resolve, 30000);  // Timeout de 30s
      
      let workersAlive = Object.keys(cluster.workers || {}).length;
      
      cluster.on("exit", () => {
        workersAlive--;
        if (workersAlive === 0) {
          clearTimeout(timeout);
          resolve(undefined);
        }
      });
    });
    
    console.log("Shutdown completo");
    process.exit(0);
  });
  
} else {
  let server: any;
  
  const app = new AzuraClient();
  server = await app.listen(3000);
  
  process.on("message", (message) => {
    if (message.type === "shutdown") {
      console.log(`Worker ${process.pid} iniciando shutdown...`);
      
      // Parar de aceitar novas conex√µes
      server.close(() => {
        console.log(`Worker ${process.pid} encerrado`);
        process.exit(0);
      });
      
      // For√ßar shutdown ap√≥s 10 segundos
      setTimeout(() => {
        console.log(`Worker ${process.pid} for√ßando shutdown`);
        process.exit(1);
      }, 10000);
    }
  });
}
```

## Zero-Downtime Deployments üöÄ

Reinicie workers um por vez para zero downtime:

```typescript
if (cluster.isPrimary) {
  let workers: any[] = [];
  
  // Fork inicial
  for (let i = 0; i < numCPUs; i++) {
    workers.push(cluster.fork());
  }
  
  // Reload gracioso
  process.on("SIGUSR2", () => {
    console.log("Iniciando reload gracioso...");
    
    const reloadWorker = (index: number) => {
      if (index >= workers.length) {
        console.log("Reload completo!");
        return;
      }
      
      const oldWorker = workers[index];
      const newWorker = cluster.fork();
      
      newWorker.once("listening", () => {
        // Matar worker antigo
        oldWorker.kill();
        workers[index] = newWorker;
        
        // Pr√≥ximo worker ap√≥s delay
        setTimeout(() => reloadWorker(index + 1), 1000);
      });
    };
    
    reloadWorker(0);
  });
}
```

## Exemplo Completo üéØ

```typescript
// server.ts
import cluster from "cluster";
import { cpus } from "os";
import { AzuraClient, applyDecorators } from "azurajs";
import { createClient } from "redis";
import { UserController } from "./controllers/UserController";

const numCPUs = cpus().length;
const PORT = 3000;

if (cluster.isPrimary) {
  console.log(`üöÄ AzuraJS Cluster Mode`);
  console.log(`üìä CPUs: ${numCPUs}`);
  console.log(`üî∑ Starting ${numCPUs} workers...`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // Auto-restart
  cluster.on("exit", (worker, code, signal) => {
    console.log(`‚ùå Worker ${worker.process.pid} died`);
    const newWorker = cluster.fork();
    console.log(`‚úÖ Worker ${newWorker.process.pid} started`);
  });
  
  // Graceful shutdown
  process.on("SIGTERM", () => {
    for (const id in cluster.workers) {
      cluster.workers[id]?.send({ type: "shutdown" });
    }
  });
  
} else {
  // Worker
  const redis = createClient();
  await redis.connect();
  
  const app = new AzuraClient({
    environment: "production",
    server: { port: PORT },
    plugins: {
      cors: { enabled: true, origin: "*" },
      rateLimit: { enabled: true, windowMs: 60000, max: 100 }
    }
  });
  
  // Middleware de sess√£o compartilhada
  app.use(async (req, res, next) => {
    const sessionId = req.cookies.sessionId;
    if (sessionId) {
      const data = await redis.get(`session:${sessionId}`);
      req.session = data ? JSON.parse(data) : {};
    }
    next();
  });
  
  // Registrar controllers
  applyDecorators(app, [UserController]);
  
  // Iniciar servidor
  const server = await app.listen(PORT);
  console.log(`‚úÖ Worker ${process.pid} listening on port ${PORT}`);
  
  // Graceful shutdown
  process.on("message", (msg) => {
    if (msg.type === "shutdown") {
      server.close(() => process.exit(0));
      setTimeout(() => process.exit(1), 10000);
    }
  });
}
```

## Melhores Pr√°ticas ‚ú®

<Callout type="tip">
  **Use Redis para estado compartilhado**: Workers n√£o compartilham mem√≥ria
</Callout>

<Callout type="tip">
  **Implemente auto-restart**: Workers podem crashar, sempre reinicie automaticamente
</Callout>

<Callout type="tip">
  **Graceful shutdown**: Aguarde requisi√ß√µes finalizarem antes de matar workers
</Callout>

<Callout type="warn">
  **Cuidado com mem√≥ria**: Cada worker consome mem√≥ria, monitore uso total
</Callout>

## Pr√≥ximos Passos üìñ

<Cards>
  <Card title="Performance" href="performance" description="Otimize ainda mais" />
  <Card title="Error Handling" href="error-handling" description="Trate erros em cluster" />
  <Card title="Exemplos" href="examples" description="Veja exemplos completos" />
</Cards>
