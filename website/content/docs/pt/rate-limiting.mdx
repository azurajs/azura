---
title: Rate Limiting
description: Proteja sua API contra abuso com rate limiting
icon: Shield
---

# Rate Limiting ğŸ›¡ï¸

Rate limiting protege sua API contra abuso limitando o nÃºmero de requisiÃ§Ãµes que um cliente pode fazer em um perÃ­odo de tempo.

## Plugin Rate Limit Embutido ğŸ“¦

AzuraJS inclui um plugin de rate limiting pronto para uso:

```typescript
import { AzuraClient } from "azurajs";

const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 60000,  // 1 minuto
      max: 100,  // 100 requisiÃ§Ãµes por janela
      message: "Muitas requisiÃ§Ãµes. Tente novamente mais tarde.",
      statusCode: 429,
      headers: true  // Adicionar cabeÃ§alhos X-RateLimit-*
    }
  }
});
```

## ConfiguraÃ§Ã£o do Plugin ğŸš¨

### OpÃ§Ãµes DisponÃ­veis

```typescript
interface RateLimitOptions {
  enabled: boolean;          // Ativar/desativar
  windowMs: number;          // Janela de tempo (ms)
  max: number;               // MÃ¡ximo de requisiÃ§Ãµes por janela
  message?: string;          // Mensagem de erro
  statusCode?: number;       // CÃ³digo de status (padrÃ£o: 429)
  headers?: boolean;         // Incluir cabeÃ§alhos X-RateLimit-*
  skipSuccessfulRequests?: boolean;  // NÃ£o contar requisiÃ§Ãµes bem-sucedidas
  skipFailedRequests?: boolean;      // NÃ£o contar requisiÃ§Ãµes com erro
  keyGenerator?: (req: RequestServer) => string;  // Gerar chave customizada
  skip?: (req: RequestServer) => boolean;         // Pular rate limit
}
```

### Exemplo Completo

```typescript
const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 900000,  // 15 minutos
      max: 100,
      message: "VocÃª atingiu o limite de requisiÃ§Ãµes. Aguarde antes de tentar novamente.",
      statusCode: 429,
      headers: true,
      skipSuccessfulRequests: false,
      skipFailedRequests: true
    }
  }
});
```

## Middleware Rate Limit Customizado ğŸ”¨

Crie seu prÃ³prio middleware de rate limiting:

```typescript
interface RateLimitRecord {
  count: number;
  resetAt: number;
}

const store = new Map<string, RateLimitRecord>();

function rateLimitMiddleware(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = req.ip;  // Usar IP como chave
    const now = Date.now();
    
    let record = store.get(key);
    
    // Criar novo registro ou resetar se janela expirou
    if (!record || now > record.resetAt) {
      record = {
        count: 1,
        resetAt: now + windowMs
      };
      store.set(key, record);
      return next();
    }
    
    // Incrementar contador
    record.count++;
    
    // Adicionar cabeÃ§alhos
    res.setHeader("X-RateLimit-Limit", max.toString());
    res.setHeader("X-RateLimit-Remaining", Math.max(0, max - record.count).toString());
    res.setHeader("X-RateLimit-Reset", new Date(record.resetAt).toISOString());
    
    // Verificar limite
    if (record.count > max) {
      return res.status(429).json({
        error: "Muitas requisiÃ§Ãµes",
        retryAfter: Math.ceil((record.resetAt - now) / 1000)
      });
    }
    
    next();
  };
}

app.use(rateLimitMiddleware(60000, 100));  // 100 req/min
```

## Rate Limit por Rota ğŸ¯

Aplique diferentes limites a diferentes rotas:

```typescript
// Rate limit restrito para autenticaÃ§Ã£o
const authRateLimit = rateLimitMiddleware(900000, 5);  // 5 tentativas em 15 min

// Rate limit normal para API
const apiRateLimit = rateLimitMiddleware(60000, 100);  // 100 req/min

// Aplicar middlewares
app.use("/auth/login", authRateLimit);
app.use("/auth/register", authRateLimit);
app.use("/api", apiRateLimit);
```

## Rate Limit por UsuÃ¡rio ğŸ‘¤

Use ID de usuÃ¡rio em vez de IP:

```typescript
function userRateLimitMiddleware(
  windowMs: number,
  max: number
) {
  const store = new Map<string, RateLimitRecord>();
  
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    // Obter ID do usuÃ¡rio do token ou sessÃ£o
    const userId = req.user?.id || req.ip;  // Fallback para IP
    const now = Date.now();
    
    let record = store.get(userId);
    
    if (!record || now > record.resetAt) {
      record = { count: 1, resetAt: now + windowMs };
      store.set(userId, record);
      return next();
    }
    
    record.count++;
    
    if (record.count > max) {
      return res.status(429).json({
        error: "Limite de requisiÃ§Ãµes atingido",
        userId
      });
    }
    
    next();
  };
}

// Aplicar apÃ³s middleware de autenticaÃ§Ã£o
app.use(authMiddleware);
app.use(userRateLimitMiddleware(60000, 1000));  // 1000 req/min por usuÃ¡rio
```

## Rate Limit DistribuÃ­do com Redis ğŸ”´

Para aplicaÃ§Ãµes com mÃºltiplas instÃ¢ncias, use Redis:

```typescript
import { createClient } from "redis";

const redis = createClient({ url: "redis://localhost:6379" });
await redis.connect();

function redisRateLimitMiddleware(
  windowMs: number,
  max: number
) {
  return async (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = `rate-limit:${req.ip}`;
    const now = Date.now();
    
    try {
      // Obter contador atual
      const data = await redis.get(key);
      let record: RateLimitRecord;
      
      if (!data) {
        // Criar novo registro
        record = { count: 1, resetAt: now + windowMs };
        await redis.setEx(key, Math.ceil(windowMs / 1000), JSON.stringify(record));
        return next();
      }
      
      record = JSON.parse(data);
      
      // Verificar se janela expirou
      if (now > record.resetAt) {
        record = { count: 1, resetAt: now + windowMs };
        await redis.setEx(key, Math.ceil(windowMs / 1000), JSON.stringify(record));
        return next();
      }
      
      // Incrementar contador
      record.count++;
      await redis.setEx(key, Math.ceil((record.resetAt - now) / 1000), JSON.stringify(record));
      
      // Verificar limite
      if (record.count > max) {
        return res.status(429).json({
          error: "Muitas requisiÃ§Ãµes",
          retryAfter: Math.ceil((record.resetAt - now) / 1000)
        });
      }
      
      next();
    } catch (error) {
      console.error("Redis rate limit error:", error);
      next();  // Falhar aberto em caso de erro do Redis
    }
  };
}

app.use(redisRateLimitMiddleware(60000, 100));
```

## Rate Limit com Sliding Window ğŸ“Š

ImplementaÃ§Ã£o mais precisa com janela deslizante:

```typescript
interface SlidingWindowRecord {
  requests: number[];  // Timestamps das requisiÃ§Ãµes
}

const store = new Map<string, SlidingWindowRecord>();

function slidingWindowRateLimit(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const key = req.ip;
    const now = Date.now();
    const windowStart = now - windowMs;
    
    let record = store.get(key);
    
    if (!record) {
      record = { requests: [] };
      store.set(key, record);
    }
    
    // Remover requisiÃ§Ãµes antigas
    record.requests = record.requests.filter(timestamp => timestamp > windowStart);
    
    // Adicionar requisiÃ§Ã£o atual
    record.requests.push(now);
    
    // Adicionar cabeÃ§alhos
    res.setHeader("X-RateLimit-Limit", max.toString());
    res.setHeader("X-RateLimit-Remaining", Math.max(0, max - record.requests.length).toString());
    
    // Verificar limite
    if (record.requests.length > max) {
      return res.status(429).json({
        error: "Muitas requisiÃ§Ãµes",
        current: record.requests.length,
        limit: max
      });
    }
    
    next();
  };
}

app.use(slidingWindowRateLimit(60000, 100));
```

## Rate Limit por Endpoint ğŸ›£ï¸

Diferentes limites para diferentes endpoints:

```typescript
@Controller("/api")
export class ApiController {
  @Post("/expensive-operation")
  expensiveOp(@Req() req: RequestServer, @Res() res: ResponseServer) {
    // Verificar rate limit especÃ­fico
    const key = `expensive:${req.ip}`;
    const limit = checkRateLimit(key, 600000, 5);  // 5 por 10 min
    
    if (!limit.allowed) {
      return res.status(429).json({
        error: "OperaÃ§Ã£o limitada a 5 por 10 minutos"
      });
    }
    
    // Executar operaÃ§Ã£o
    return { result: "ok" };
  }

  @Get("/public-data")
  publicData(@Req() req: RequestServer, @Res() res: ResponseServer) {
    // Rate limit mais permissivo
    const key = `public:${req.ip}`;
    const limit = checkRateLimit(key, 60000, 1000);  // 1000 por min
    
    if (!limit.allowed) {
      return res.status(429).json({ error: "Rate limit exceeded" });
    }
    
    return { data: "public" };
  }
}

function checkRateLimit(key: string, windowMs: number, max: number) {
  // ImplementaÃ§Ã£o similar aos exemplos anteriores
  // ...
  return { allowed: true, remaining: max };
}
```

## Whitelist e Blacklist ğŸ“

Skip rate limiting para IPs confiÃ¡veis:

```typescript
const WHITELISTED_IPS = new Set([
  "127.0.0.1",
  "::1",
  "10.0.0.1"  // IP interno
]);

const BLACKLISTED_IPS = new Set([
  "192.168.1.100"  // IP banido
]);

function rateLimitWithWhitelist(
  windowMs: number,
  max: number
) {
  return (req: RequestServer, res: ResponseServer, next: () => void) => {
    const ip = req.ip;
    
    // Bloquear IPs banidos
    if (BLACKLISTED_IPS.has(ip)) {
      return res.status(403).json({ error: "IP banido" });
    }
    
    // Pular rate limit para IPs confiÃ¡veis
    if (WHITELISTED_IPS.has(ip)) {
      return next();
    }
    
    // Aplicar rate limit normal
    // ... implementaÃ§Ã£o de rate limit
    next();
  };
}

app.use(rateLimitWithWhitelist(60000, 100));
```

## CabeÃ§alhos de Rate Limit ğŸ“‹

Adicione cabeÃ§alhos informativos:

```typescript
function addRateLimitHeaders(
  res: ResponseServer,
  limit: number,
  remaining: number,
  resetAt: number
) {
  res.setHeader("X-RateLimit-Limit", limit.toString());
  res.setHeader("X-RateLimit-Remaining", remaining.toString());
  res.setHeader("X-RateLimit-Reset", resetAt.toString());
  res.setHeader("Retry-After", Math.ceil((resetAt - Date.now()) / 1000).toString());
}
```

## Exemplos PrÃ¡ticos ğŸ¨

### Rate Limit para API REST

```typescript
const app = new AzuraClient({
  plugins: {
    rateLimit: {
      enabled: true,
      windowMs: 900000,  // 15 minutos
      max: 1000,
      headers: true
    }
  }
});

// Rate limit mais restrito para operaÃ§Ãµes de escrita
const writeRateLimit = rateLimitMiddleware(60000, 50);  // 50 escritas/min

app.use("/api", apiRateLimit);
app.post("*", writeRateLimit);
app.put("*", writeRateLimit);
app.delete("*", writeRateLimit);
```

### Rate Limit para AutenticaÃ§Ã£o

```typescript
const authRateLimit = rateLimitMiddleware(900000, 5);  // 5 tentativas/15min

@Controller("/auth")
export class AuthController {
  @Post("/login")
  async login(
    @Body() credentials: any,
    @Req() req: RequestServer,
    @Res() res: ResponseServer
  ) {
    // Verificar rate limit manualmente
    const key = `login:${req.ip}`;
    const limit = checkRateLimit(key, 900000, 5);
    
    if (!limit.allowed) {
      return res.status(429).json({
        error: "Muitas tentativas de login",
        retryAfter: limit.retryAfter
      });
    }
    
    // Tentar autenticar
    const user = await authenticate(credentials);
    
    if (!user) {
      return res.status(401).json({ error: "Credenciais invÃ¡lidas" });
    }
    
    res.json({ user });
  }
}
```

## Melhores PrÃ¡ticas âœ¨

<Callout type="tip">
  **Use Redis para ambientes distribuÃ­dos**: Garante limites consistentes em mÃºltiplas instÃ¢ncias
</Callout>

<Callout type="tip">
  **Diferentes limites para diferentes endpoints**: Proteja operaÃ§Ãµes sensÃ­veis com limites mais rigorosos
</Callout>

<Callout type="tip">
  **Sempre adicione cabeÃ§alhos**: Ajude clientes a entender os limites
</Callout>

<Callout type="warn">
  **Cuidado com proxies**: Use `req.ip` que considera cabeÃ§alhos X-Forwarded-For
</Callout>

<Callout type="warn">
  **NÃ£o bloqueie tudo**: Whitelist IPs internos e de monitoramento
</Callout>

## PrÃ³ximos Passos ğŸ“–

<Cards>
  <Card title="CORS" href="cors" description="Configure CORS" />
  <Card title="Middleware" href="middleware" description="Crie middleware customizado" />
  <Card title="Error Handling" href="error-handling" description="Trate erros de rate limit" />
</Cards>
